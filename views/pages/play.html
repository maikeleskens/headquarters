<!-- <html>
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script type="text/javascript">

	if ( !window.requestAnimationFrame ) {
		window.requestAnimationFrame = ( function() {
			return window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
				window.setTimeout( callback, 1000 / 60 );
			};
		} )();
	}

	var socket = io.connect();
	var currentID;

	var xpos = 0;
	var ypos = 0;

	window.onload = function(){
		socket.emit("requestID", {playerName: "maikel"});
	}

	socket.on("receiveID", function(data){
		console.log("received id: " + data.id_num);
		document.getElementById("myID").innerHTML= data.id_num;
		currentID = data.id_num;
	});


	socket.on("removeMe", function(data){
		var _id = parseInt(data.id);
		console.log(_id);
		if (_id == currentID){
			socket.emit("userDisconnected", {remove_id : currentID});
			window.location.href = "/afk";
		}
	})

	function moveUp(){
		ypos= -10;
		sendData();
	}

	function moveDown(){
		ypos = 10;
		sendData();
	}
	function moveLeft(){
		xpos = -10;
		sendData();
	}
	function moveRight(){
		xpos=10;
		sendData();
	}

	function sendData(){
		socket.emit("dataTransfer", {
			id_num : currentID,
			x : xpos,
			y : ypos
		});
		console.log("sendtest");
		ypos= 0;
		xpos=0;
	}
	
	window.onbeforeunload = closingCode;
	function closingCode(){
		socket.emit("userDisconnected", {remove_id : currentID});
   		return null;
	}

	</script>
</head>

<body>
<span id="myID"> No ID received </span>

<button onClick="moveUp()">Up </button>
<button onClick="moveDown()">Down </button>
<button onClick="moveLeft()">Left </button>
<button onClick="moveRight()">Right </button>


</body>
</html> -->

<!doctype html>
<html lang=en>
<head>
	<meta charset=utf-8>
	<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0" /> 
	<title></title>
	<script src="/js/Vector2.js"></script>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
	<script src="/socket.io/socket.io.js"></script>
	<style type="text/css"> 
	
	* {
		-webkit-touch-callout: none; /* prevent callout to copy image, etc when tap to hold */
		-webkit-text-size-adjust: none; /* prevent webkit from resizing text to fit */
		/* make transparent link selection, adjust last value opacity 0 to 1.0 */
		-webkit-tap-highlight-color: rgba(0,0,0,0); 
		-webkit-user-select: none; /* prevent copy paste, to allow, change 'none' to 'text' */
		-webkit-tap-highlight-color: rgba(0,0,0,0); 
	}
	
	body {
		background-color: #000000;
		margin: 0px;
	}
	canvas {
		background-color:#111133;
		display:block; 
		position:absolute; 
	}
	.container {
		width:auto;
		text-align:center;
		background-color:#ff0000;
	}

	.box{
		width: 600px;
		height:150px;
		background-color: #ffffff;
		color: #000000;
		font-size: 24px;
		z-index: 999;
		position: fixed;
	}
	</style>


</head>
<body onload = "init()">


	<!--TEMP  DATA -->
	<div class="box">
		<span id="myID">No ID yet</span>
		<span id="showpositions"> No positions yet</span>
	</div>




	<script type="text/javascript">

	if ( !window.requestAnimationFrame ) {
		window.requestAnimationFrame = ( function() {
			return window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {
				window.setTimeout( callback, 1000 / 60 );
			};
		} )();
	}

	var socket = io.connect();
	var currentID;
	var newX = 0;
	var newY = 0;

	window.onload = function(){
		socket.emit("requestID", {playerName: "maikel"});
	}

	socket.on("receiveID", function(data){
		console.log("received id: " + data.id_num);
		document.getElementById("myID").innerHTML= data.id_num;
		currentID = data.id_num;
	});


	socket.on("removeMe", function(data){
		var _id = parseInt(data.id);
		console.log(_id);
		if (_id == currentID){
			socket.emit("userDisconnected", {remove_id : currentID});
			window.location.href = "/afk";
		}
	})
	function onMouseMove(event) {
		mouseX = event.offsetX;
		mouseY = event.offsetY;
	}

	// function sendData(_newX, _newY){
		
	// }
	
	window.onbeforeunload = closingCode;
	function closingCode(){
		socket.emit("userDisconnected", {remove_id : currentID});
		return null;
	}

	var canvas,
 	c, // c is the canvas' context 2D
 	container,
 	halfWidth, 
 	halfHeight,
 	leftTouchID = -1,
 	leftTouchPos = new Vector2(0,0),
 	leftTouchStartPos = new Vector2(0,0),
 	leftVector = new Vector2(0,0);

 	var maxDragRange = 100;
 	var timer =0


 	setupCanvas();

 	var mouseX, mouseY, 
	// is this running in a touch capable environment?
	touchable = 'createTouch' in document,
	touches = []; // array of touch vectors


	setInterval(draw, 1000/35); 
	if(touchable) {
		canvas.addEventListener( 'touchstart', onTouchStart, false );
		canvas.addEventListener( 'touchmove', onTouchMove, false );
		canvas.addEventListener( 'touchend', onTouchEnd, false );
		window.onorientationchange = resetCanvas;  
		window.onresize = resetCanvas;  
	} else {

		canvas.addEventListener( 'mousemove', onMouseMove, false );
	}


	function resetCanvas (e) {  
 	// resize the canvas - but remember - this clears the canvas too. 
 	canvas.width = window.innerWidth; 
 	canvas.height = window.innerHeight;

 	halfWidth = canvas.width/2; 
 	halfHeight = canvas.height/2;

	//make sure we scroll to the top left. 
	window.scrollTo(0,0); 
}
function init(){
	
}
function draw() {

	c.clearRect(0,0,canvas.width, canvas.height); 
	
	
	
	if(touchable) {

		for(var i=0; i<touches.length; i++) {
			
			var touch = touches[i]; 
			
			if(touch.identifier == leftTouchID){
				c.beginPath(); 
				c.strokeStyle = "cyan"; 
				c.lineWidth = 6; 
				c.arc(leftTouchStartPos.x, leftTouchStartPos.y, 40,0,Math.PI*2,true); 
				c.stroke();
				c.beginPath(); 
				c.strokeStyle = "cyan"; 
				c.lineWidth = 2; 
				c.arc(leftTouchStartPos.x, leftTouchStartPos.y, 60,0,Math.PI*2,true); 
				c.stroke();
				c.beginPath(); 
				c.strokeStyle = "cyan"; 
				c.arc(leftTouchPos.x, leftTouchPos.y, 40, 0,Math.PI*2, true); 
				c.stroke(); 

				newX = MinMax(parseInt(leftTouchPos.x) - parseInt(leftTouchStartPos.x), -maxDragRange, maxDragRange)/maxDragRange; 
				newY = MinMax(parseInt(leftTouchPos.y) - parseInt(leftTouchStartPos.y), -maxDragRange, maxDragRange)/maxDragRange;



				//THIS SHIT MADE THE APP SO DAMN SLOW
				// document.getElementById("showpositions").innerHTML= "Touch ID: " + leftTouchID + ", Start X: " + parseInt(leftTouchStartPos.x) + ", Start Y: " + parseInt(leftTouchStartPos.y) + ", Current X: " + parseInt(leftTouchPos.x) + ", Current Y: " + parseInt(leftTouchPos.y) + ", --- Speed X: " + newX + ", Speed Y: " + newY; 

				// sendData(newX, newY);
				

				
			} else {
				
				c.beginPath(); 
				c.fillStyle = "white";
				c.fillText("touch id : "+touch.identifier+" x:"+touch.clientX+" y:"+touch.clientY, touch.clientX+30, touch.clientY-30); 
				c.beginPath(); 
				c.strokeStyle = "red";
				c.lineWidth = "6";
				c.arc(touch.clientX, touch.clientY, 40, 0, Math.PI*2, true); 
				c.stroke();
			}
		}
	} else {
		
		c.fillStyle	 = "white"; 
		c.fillText("mouse : "+mouseX+", "+mouseY, mouseX, mouseY); 
		
	}
	//c.fillText("hello", 0,0); 
	timer++;
		if (timer >5 && newX!=0 && newY !=0){
			socket.emit("dataTransfer", {
				id_num : currentID,
				x : newX,
				y : newY
			});

		newX=0;
		newY=0;
		timer=0;
	}
}
/*	
 *	Touch event (e) properties : 
 *	e.touches: 			Array of touch objects for every finger currently touching the screen
 *	e.targetTouches: 	Array of touch objects for every finger touching the screen that
 *						originally touched down on the DOM object the transmitted the event.
 *	e.changedTouches	Array of touch objects for touches that are changed for this event. 					
 *						I'm not sure if this would ever be a list of more than one, but would 
 *						be bad to assume. 
 *
 *	Touch objects : 
 *
 *	identifier: An identifying number, unique to each touch event
 *	target: DOM object that broadcast the event
 *	clientX: X coordinate of touch relative to the viewport (excludes scroll offset)
 *	clientY: Y coordinate of touch relative to the viewport (excludes scroll offset)
 *	screenX: Relative to the screen
 *	screenY: Relative to the screen
 *	pageX: Relative to the full page (includes scrolling)
 *	pageY: Relative to the full page (includes scrolling)
 */	
 function onTouchStart(e) {

 	for(var i = 0; i<e.changedTouches.length; i++){
 		var touch =e.changedTouches[i]; 
		//console.log(leftTouchID + " " 
			if((leftTouchID<0) && (touch.clientX<halfWidth))
			{
				leftTouchID = touch.identifier; 
				leftTouchStartPos.reset(touch.clientX, touch.clientY); 	
				leftTouchPos.copyFrom(leftTouchStartPos); 
				leftVector.reset(0,0); 
				continue; 		
			} else {

			}	
		}
		touches = e.touches; 
	}

	function onTouchMove(e) {
	 // Prevent the browser from doing its default thing (scroll, zoom)
	 e.preventDefault();

	 for(var i = 0; i<e.changedTouches.length; i++){
	 	var touch =e.changedTouches[i]; 
	 	if(leftTouchID == touch.identifier)
	 	{
	 		leftTouchPos.reset(touch.clientX, touch.clientY); 
	 		leftVector.copyFrom(leftTouchPos); 
	 		leftVector.minusEq(leftTouchStartPos); 	
	 		break; 		
	 	}		
	 }

	 touches = e.touches; 

	} 

	function onTouchEnd(e) { 

		touches = e.touches; 
		for(var i = 0; i<e.changedTouches.length; i++){
			var touch =e.changedTouches[i]; 
			if(leftTouchID == touch.identifier)
			{
				leftTouchID = -1; 
				leftVector.reset(0,0); 
				break; 		
			}		
		}

	}



	function setupCanvas() {

		canvas = document.createElement( 'canvas' );
		c = canvas.getContext( '2d' );
		container = document.createElement( 'div' );
		container.className = "container";
		document.body.appendChild( container );
		container.appendChild(canvas);	
		resetCanvas(); 

		c.strokeStyle = "#ffffff";
		c.lineWidth =2;	
	}

	function MinMax(value, min, max) {
		return(Math.min(max, Math.max(min, value)));
	}
	</script>
</body>
</html>